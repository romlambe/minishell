
- exit => OK
- ctrl + c => OK
- < end.txt wc -l < file.txt cat
=> Error to handle
- echo '"SALUT'"
=> Quotes are not closed, error to manage
- entree => OK
- Que des espaces : OK
=> Devrait renvoyer a la ligne.
TO TEST : DONE
$> echo hola > bonjour
$> echo hey > hello
$> <bonjour >hello
$> cat bonjour 
$> cat hello

cat > ok 
...
...
cat < ok => DONE
- Gestion env + update => DONE


- > - | - < - \ 
=> Erreurs a gerer pour arreter le prog.

- Minishell>$echo -nnn ------------------n
malloc(): corrupted top size

- echo >< | echo > < + gestion | | + etc.
=> SEGFAULT
Gerer les erreurs de syntaxe !

- $VAR.ENV.:
Check dans la tokenisation > Checker dans la string : 
1. tant que str & que pas $
2. puis que pas autre $
3. Check si var. d'env. 
4. On modifie
=> Check AVANT la gestion des quotes !

- Try a command like : echo "cat lol.c | cat > lol.c"
=> Need to put things inside quotes in a node (like option)
& not creating different nodes.
- Absolute path => Check how to manage it

- REVOIR FONCTION QUOTES ! => OK ?
On avance de gauche a droite > On check chaque quote,
si un niveau de quote on retire, sinon d'autres dedans,
on affiche ce qu'il y a l'interieur.

Quand guillemets tu ouvres, puis
si meme guillemets et rien avant > on ouvre.
Sinon si meme guillemets > Ferme et i--;
Sinon, on ajoute le texte : 
si i != 0, pb de guillemets.

- Quotes avec $ => Pas besoin des doubles quote pour
avoir la var. d'env.
Par contre, si ne trouve pas => Retire le bout.
=> Gerer dans le parsing : 
- Si tu trouves double quotes & 

JEZA : TO DO

- Gerer echo SALUT > OK | cat OK => DONE with check_line function because
i'm waiting for each block, so the end of each cmd, then cat can access to ok file.
=> So how to do it ??
- Tester de nouveau les file seuls ! + voir pour append/output or else.
=> DONE : i'm can now verify if there is one file if it exists or not.
=> BUT it's not totally good bce if i have a file & then a pipe, ça
fait la redirection du file sur STDOUT ce qui fait qu'il envoie les données à
cat alors que normalement cat ne reçoit rien.
idée : créer une autre fonction d'output pour l'output seul. => DONE

- Mettre l'env. dans une structure et tout remplacer. => DONE
- Le mettre à jour et pouvoir y accéder, actualisé, à tout moment. => DONE
- Absolute path : => DONE
Checker si abolute path : Si je rencontre un slash alors absolute path !
On va pas chercher le path, on l'envoie direct a execve.


< ok | cat / wc => why send it to the cmd ? => DONE

<< end | cat => OK

- Checker parsing & execution => Invalid read of size.
- Parsing : Check des files => Faire toutes les combinaisons : 
1. Output output
2. Output append
3. Append append
4. Append output
=> Check si besoin de le faire pour here_doc aussi ?

- Quotes : 
Important => Les quotes doivent être gérés dès le début avant de split la ligne de commande.
1. Mettre la gestion des quotes au début, pour gérer directement l'input.
2. Lui envoyer une string au lieu d'un tableau de tableau !

- Echo : 
1. Gérer tous les cas d'erreurs qui n'ont pas été fait (fonction error)
2. Voir comment gérer la var. d'env au parsing (?) => Si existe pas > Retiré de la ligne de cmd.
3. Problème du split à voir => Parce que si var. d'env géré avant + $ > Pas besoin.
=> Si echo a $HOME il print home et pas la var. d'env.
=> Par contre il retire le $.
+ Gerer les quotes avant echo.

Attention : Si en input j'ai export HOLA=ok le parsing ne me
met pas d'espace !!

Exit : DONE => But check if with pipe doesn't work. => DONE
exit | ls => Do ls but not exit ! => OK

Unset : DONE
Can't find the var. i've just added. => DONE
Check errors like export. => OK

pwd : DONE
- Errors => OK
- Tester si MAJ dans l'env. => OK

export :
- Ne pas afficher la derniere ligne de l'env.

CD : 
Si cd xxx puis env => Marche plus
- Si // on print deux slash avec \n.
- Sinon on print un slash avec \n.
- cd .. => 2 fois SEGFAULT


Quotes & Var. d'env : 
- D'abord on gere les quotes et ensuite la var. d'env.
=> Par contre il faut gerer les quotes avant et donc reconnaitre
le type de quotes :
- Si simple > c'est une phrase litterale > On garde le texte.
- Si double ou rien > c'est une variable > On change par sa valeur.
Var. Env. : 
- Si entre double quote ou tout seul => On met la valeur de la variable d'env.
- Si entre si;ple quote => On laisse tel quel et on envoie a echo.

Code de sortie : 
=> Mettre a jour a chq sortie du programme.
=> Dans le parsing > Remplacer.
> Si code d'erreur tout seul = error
> Si code erreur avec echo > OK

Gestion d'erreurs : DONE
Si cmd avec quotes pas fermes ! => Errors.

HERE_DOC SOLO : DONE
=> SEGFAULT

cat | < end.txt : DONE
=> SEGFAULT

echo SALUT > output => Print sur le terminal et pas dans le fichier. => DONE

echo : 
Si \ alors on skip ce caractere.

